# B0-01-03 实现计划：发布执行器（调度Agent执行apply_config，批次推进，失败隔离）

## 任务概述

实现发布执行器，把B0-01-02生成的release_task真正"跑起来"：按batch顺序执行，batch内并发执行，任一节点失败则发布任务失败，全部成功则发布任务成功。

## 核心目标

1. 实现AgentClient（封装对Agent的HTTP调用，支持mTLS）
2. 实现ReleaseExecutor（状态机 + 批次推进逻辑）
3. 实现后台触发器（ticker + 执行循环）
4. 实现发布状态查询API（GET /api/v1/releases/{id}）
5. 编写验收测试（12+条SQL + 10+条curl）

## 执行规则

### 批次推进逻辑

1. 读取release_task_nodes，找最小batch且status in (pending, running, failed)的batch作为current batch
2. current batch内：
   - 对status=pending的node：dispatch apply_config → 标记node running（写started_at）
   - 对status=running的node：轮询task状态，成功→success（写finished_at），失败→failed（写finished_at + error_msg）
3. batch内任一failed：
   - release_tasks.status = failed
   - release_tasks.failed_nodes 递增准确
   - 后续batch的nodes全部标记skipped
   - 停止执行
4. batch全success：进入下一个batch
5. 所有batch全success：release_tasks.status = success

### 计数要求

- total_nodes：在创建时已写入
- success_nodes/failed_nodes：在执行过程中维护准确

### 失败隔离

- 任一节点失败：发布任务失败，后续batch不再执行
- 失败不影响已成功节点

## 实现阶段

### Phase 1: 任务分析
- 创建实现计划文档
- 确认AgentClient接口和ReleaseExecutor逻辑

### Phase 2: 实现AgentClient
- internal/agentclient/client.go（封装对Agent的HTTP调用）
- internal/agentclient/types.go（请求/响应结构）
- 复用mTLS配置（T2-02的client方案）
- 支持超时（15s connect / 60s request）
- 提供Dispatch和Query方法

### Phase 3: 实现ReleaseExecutor
- internal/release/executor.go（RunOnce / RunLoop）
- internal/release/runner.go（对单个release_task的执行状态机）
- 批次推进逻辑（按batch顺序执行）
- 失败隔离（任一节点失败则停止）
- 状态抢占（避免多进程重复执行）

### Phase 4: 实现后台触发器
- 在main.go中启动executor loop
- 每2~5秒扫一次可执行任务
- 使用ENV控制开关：RELEASE_EXECUTOR_ENABLED=1

### Phase 5: 实现发布状态查询API
- GET /api/v1/releases/{id}
- 返回release.status和nodes按batch分组的状态

### Phase 6: 编写验收测试
- 12+条SQL验证
- 10+条curl验证

### Phase 7: 生成交付报告
- 改动文件清单
- SQL验证结果
- curl验证结果
- 回滚策略

## 技术要点

### 1. AgentClient

```go
type Client struct {
    httpClient *http.Client // mTLS client
    baseURL    string
    timeout    time.Duration
}

// Dispatch 发送apply_config任务到Agent
func (c *Client) Dispatch(nodeIP string, version int64) (taskID string, err error)

// Query 查询任务状态
func (c *Client) Query(nodeIP string, taskID string) (status string, lastError string, err error)
```

### 2. ReleaseExecutor

```go
type Executor struct {
    db          *gorm.DB
    agentClient *agentclient.Client
    interval    time.Duration
}

// RunOnce 执行一次扫描
func (e *Executor) RunOnce() error

// RunLoop 循环执行
func (e *Executor) RunLoop(ctx context.Context)
```

### 3. 状态抢占

使用UPDATE ... WHERE status='pending'的方式抢占：

```go
result := db.Exec("UPDATE release_tasks SET status='running' WHERE id=? AND status='pending'", taskID)
if result.RowsAffected == 0 {
    // 已被其他进程抢占，跳过
    return nil
}
```

### 4. 批次推进

```go
func (e *Executor) processBatch(releaseTask *model.ReleaseTask, batch int) error {
    // 1. 获取当前batch的所有nodes
    nodes := getNodesByBatch(releaseTask.ID, batch)
    
    // 2. dispatch pending nodes
    for _, node := range nodes {
        if node.Status == "pending" {
            taskID, err := e.agentClient.Dispatch(node.NodeIP, releaseTask.Version)
            if err != nil {
                // 标记为failed
                markNodeFailed(node.ID, err.Error())
                return err
            }
            markNodeRunning(node.ID, taskID)
        }
    }
    
    // 3. poll running nodes
    for _, node := range nodes {
        if node.Status == "running" {
            status, lastError, err := e.agentClient.Query(node.NodeIP, node.TaskID)
            if err != nil {
                // 查询失败，标记为failed
                markNodeFailed(node.ID, err.Error())
                return err
            }
            if status == "success" {
                markNodeSuccess(node.ID)
            } else if status == "failed" {
                markNodeFailed(node.ID, lastError)
                return errors.New("node failed")
            }
        }
    }
    
    // 4. 检查batch是否全部成功
    if allSuccess(nodes) {
        return nil // 进入下一个batch
    }
    
    return errors.New("batch not complete")
}
```

### 5. 失败隔离

```go
func (e *Executor) handleFailure(releaseTask *model.ReleaseTask) error {
    // 1. 更新release_tasks.status = failed
    db.Model(&model.ReleaseTask{}).Where("id = ?", releaseTask.ID).
        Update("status", "failed")
    
    // 2. 更新failed_nodes计数
    failedCount := countFailedNodes(releaseTask.ID)
    db.Model(&model.ReleaseTask{}).Where("id = ?", releaseTask.ID).
        Update("failed_nodes", failedCount)
    
    // 3. 标记后续batch的nodes为skipped
    currentBatch := getCurrentBatch(releaseTask.ID)
    db.Model(&model.ReleaseTaskNode{}).
        Where("release_task_id = ? AND batch > ? AND status = 'pending'", releaseTask.ID, currentBatch).
        Update("status", "skipped")
    
    return nil
}
```

## 验收测试

### SQL验证（12+条）

1. 创建release（3个online node）
2. 验证release_tasks初始状态（status=pending）
3. 验证release_task_nodes初始状态（status=pending）
4. 执行executor.RunOnce()
5. 验证batch1节点状态变化（pending→running→success）
6. 验证batch2节点状态变化（pending→running→success）
7. 验证release_tasks最终状态（status=success）
8. 验证success_nodes计数正确
9. 模拟batch1失败
10. 验证release_tasks状态（status=failed）
11. 验证batch2节点状态（status=skipped）
12. 验证failed_nodes计数正确

### curl验证（10+条）

1. 创建3个online node
2. POST /api/v1/releases创建任务
3. GET /api/v1/releases/{id}查询状态（pending）
4. 启动executor
5. GET /api/v1/releases/{id}查询状态（running）
6. 等待执行完成
7. GET /api/v1/releases/{id}查询状态（success）
8. 模拟1个node Agent不可达
9. POST /api/v1/releases创建任务
10. GET /api/v1/releases/{id}查询状态（failed）
11. 验证batch2 skipped
12. 重复启动executor不会重复执行同一release

## 禁止事项

1. 禁止修改Agent仓库
2. 禁止新增Agent接口（只能适配现有接口）
3. 禁止在executor里渲染nginx配置
4. 禁止在executor里生成证书或DNS
5. 禁止使用图标（emoji）

## 回滚策略

### 关闭executor
```bash
export RELEASE_EXECUTOR_ENABLED=0
```

### 代码回滚
```bash
git revert <commit_hash>
```

### 数据保留
不删除历史release数据（保留审计）

## 验收标准

1. 控制端能自动推进release（pending→running→success/failed）
2. batch顺序严格执行
3. 失败隔离严格成立（失败不影响已成功节点，后续批次不执行）
4. 不改Agent也能跑通
5. go test ./... 通过
6. 至少12条SQL验证通过
7. 至少10条curl验证通过

## 交付清单

- [ ] internal/agentclient/client.go
- [ ] internal/agentclient/types.go
- [ ] internal/release/executor.go
- [ ] internal/release/runner.go
- [ ] api/v1/releases/handler.go（更新，添加GET /{id}）
- [ ] api/v1/router.go（更新，注册GET /releases/{id}）
- [ ] cmd/cmdb/main.go（更新，启动executor loop）
- [ ] internal/config/config.go（更新，添加executor配置）
- [ ] scripts/test_release_executor.sh（验收测试）
- [ ] docs/B0-01-03-DELIVERY.md（交付报告）
